/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.github.thake.avro4k.compiler;

import org.apache.avro.JsonProperties;
import org.apache.avro.Protocol;
import org.apache.avro.Schema;
import org.apache.avro.Schema.Field;
import org.apache.commons.text.StringEscapeUtils;
import org.apache.velocity.Template;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.runtime.RuntimeConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.util.*;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.apache.avro.specific.SpecificData.RESERVED_WORDS;

/**
 * Generate avro4k kotlin classes for schemas.
 */
public class Avro4kCompiler {

    /* Reserved words for accessor/mutator methods */
    private static final Set<String> ACCESSOR_MUTATOR_RESERVED_WORDS = new HashSet<>(Arrays.asList("class"));
    /* Reserved words for error types */
    private static final Set<String> ERROR_RESERVED_WORDS = new HashSet<>(Arrays.asList("message", "cause"));
    private static final String FILE_HEADER =
            "/**\n" + " * Autogenerated by Avro\n" + " *\n" + " * DO NOT EDIT DIRECTLY\n" + " */\n";
    private static final Schema NULL_SCHEMA = Schema.create(Schema.Type.NULL);

    static {
        // Add reserved words to accessor/mutator reserved words
        ACCESSOR_MUTATOR_RESERVED_WORDS.addAll(RESERVED_WORDS);
    }

    static {
        // Add accessor/mutator reserved words to error reserved words
        ERROR_RESERVED_WORDS.addAll(ACCESSOR_MUTATOR_RESERVED_WORDS);
    }

    private final Set<Schema> queue = new HashSet<>();
    private List<LogicalTypeConversion> logicalTypeConversions = new ArrayList<>();
    private Protocol protocol;
    private VelocityEngine velocityEngine;
    private String templateDir;
    private FieldVisibility fieldVisibility = FieldVisibility.PUBLIC;
    private boolean createSetters = false;
    private String outputCharacterEncoding;
    private String suffix = ".kt";
    private List<Object> additionalVelocityTools = new ArrayList<>();
    private Map<String, String> renamedClasses = new HashMap<>();

    public Avro4kCompiler(Protocol protocol) {
        this();
        // enqueue all types
        for (Schema s : protocol.getTypes()) {
            enqueue(s);
        }
        this.protocol = protocol;
    }

    public Avro4kCompiler(Schema schema) {
        this();
        enqueue(schema);
        this.protocol = null;
    }

    /**
     * Creates an avro4k compiler.
     */
    Avro4kCompiler() {
        this.templateDir = System.getProperty("com.github.thake.avro4k.compiler.templates",
                                              "/com/github/thake/avro4k/compiler/templates/");
        initializeVelocity();
        initializeSpecificData();
    }

    /**
     * Generates Java interface and classes for a protocol.
     *
     * @param src  the source Avro protocol file
     * @param dest the directory to place generated files in
     */
    public static void compileProtocol(File src, File dest) throws IOException {
        compileProtocol(new File[] { src }, dest);
    }

    /**
     * Generates Java interface and classes for a number of protocol files.
     *
     * @param srcFiles the source Avro protocol files
     * @param dest     the directory to place generated files in
     */
    public static void compileProtocol(File[] srcFiles, File dest) throws IOException {
        for (File src : srcFiles) {
            Protocol protocol = Protocol.parse(src);
            Avro4kCompiler compiler = new Avro4kCompiler(protocol);
            compiler.compileToDestination(src, dest);
        }
    }

    /**
     * Generates Java classes for a schema.
     */
    public static void compileSchema(File src, File dest) throws IOException {
        compileSchema(new File[] { src }, dest);
    }

    /**
     * Generates Java classes for a number of schema files.
     */
    public static void compileSchema(File[] srcFiles, File dest) throws IOException {
        Schema.Parser parser = new Schema.Parser();

        for (File src : srcFiles) {
            Schema schema = parser.parse(src);
            Avro4kCompiler compiler = new Avro4kCompiler(schema);
            compiler.compileToDestination(src, dest);
        }
    }

    /**
     * Utility for template use. Adds a dollar sign to reserved words.
     */
    public static String mangle(String word) {
        return mangle(word, false);
    }

    /**
     * Utility for template use. Adds a dollar sign to reserved words.
     */
    public static String mangle(String word, boolean isError) {
        return mangle(word, isError ? ERROR_RESERVED_WORDS : RESERVED_WORDS);
    }

    /**
     * Utility for template use. Adds a dollar sign to reserved words.
     */
    public static String mangle(String word, Set<String> reservedWords) {
        return mangle(word, reservedWords, false);
    }

    /**
     * Utility for template use. Adds a dollar sign to reserved words.
     */
    public static String mangle(String word, Set<String> reservedWords, boolean isMethod) {
        if (word.contains(".")) {
            // If the 'word' is really a full path of a class we must mangle just the
            // classname
            int lastDot = word.lastIndexOf(".");
            String packageName = word.substring(0, lastDot + 1);
            String className = word.substring(lastDot + 1);
            return packageName + mangle(className, reservedWords, isMethod);
        }
        if (reservedWords.contains(word) || (isMethod && reservedWords.contains(
                Character.toLowerCase(word.charAt(0)) + ((word.length() > 1) ? word.substring(1) : "")))) {
            return word + "$";
        }
        return word;
    }

    public static void main(String[] args) throws Exception {
        // compileSchema(new File(args[0]), new File(args[1]));
        compileProtocol(new File(args[0]), new File(args[1]));
    }

    /**
     * Set additional Velocity tools (simple POJOs) to be injected into the Velocity
     * template context.
     */
    public void setAdditionalVelocityTools(List<Object> additionalVelocityTools) {
        this.additionalVelocityTools = additionalVelocityTools;
    }

    /**
     * Set the resource directory where templates reside. First, the compiler checks
     * the system path for the specified file, if not it is assumed that it is
     * present on the classpath.
     */
    public void setTemplateDir(String templateDir) {
        this.templateDir = templateDir;
    }

    public Map<String, String> getRenamedClasses() {
        return renamedClasses;
    }

    public void setRenamedClasses(Map<String, String> renamedClasses) {
        this.renamedClasses = renamedClasses;
    }

    /**
     * @return true if the record fields should be public
     */
    public boolean publicFields() {
        return (this.fieldVisibility == FieldVisibility.PUBLIC);
    }

    /**
     * @return true if the record fields should be private
     */
    public boolean privateFields() {
        return (this.fieldVisibility == FieldVisibility.PRIVATE);
    }

    public boolean internalFields() {
        return (this.fieldVisibility == FieldVisibility.INTERNAL);
    }

    public boolean protectedFields() {
        return (this.fieldVisibility == FieldVisibility.PROTECTED);
    }

    /**
     * Sets the field visibility option.
     */
    public void setFieldVisibility(FieldVisibility fieldVisibility) {
        this.fieldVisibility = fieldVisibility;
    }

    public boolean isCreateSetters() {
        return this.createSetters;
    }

    /**
     * Set to false to not create setter methods for the fields of the record.
     */
    public void setCreateSetters(boolean createSetters) {
        this.createSetters = createSetters;
    }

    private void initializeVelocity() {
        this.velocityEngine = new VelocityEngine();

        // These properties tell Velocity to use its own classpath-based
        // loader, then drop down to check the root and the current folder

        velocityEngine.addProperty(RuntimeConstants.RESOURCE_LOADERS, "class, file");
        velocityEngine.addProperty("resource.loader.class.class",
                                   "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader");
        velocityEngine.addProperty("resource.loader.file.class",
                                   "org.apache.velocity.runtime.resource.loader.FileResourceLoader");
        velocityEngine.addProperty("resource.loader.file.path", "/, .");
        velocityEngine.setProperty("runtime.strict_mode.enable", true);

        // Set whitespace gobbling to Backward Compatible (BC)
        // https://velocity.apache.org/engine/2.0/developer-guide.html#space-gobbling
        velocityEngine.setProperty("parser.space_gobbling", RuntimeConstants.SpaceGobbling.LINES.name());
    }

    private void initializeSpecificData() {
        addLogicalTypeConversion(new DateLogicalTypeConversion());
        addLogicalTypeConversion(new TimestampMillisTypeConversion());
        addLogicalTypeConversion(new TimestampMillisTypeConversion());
        addLogicalTypeConversion(new DecimalLogicalTypeConversion());
    }

    public void addLogicalTypeConversion(LogicalTypeConversion logicalTypeConversion) {
        logicalTypeConversions.add(0, logicalTypeConversion);
    }

    /**
     * Recursively enqueue schemas that need a class generated.
     */
    private void enqueue(Schema schema) {
        if (queue.contains(schema))
            return;
        switch (schema.getType()) {
        case RECORD:
            queue.add(schema);
            for (Schema.Field field : schema.getFields())
                enqueue(field.schema());
            break;
        case MAP:
            enqueue(schema.getValueType());
            break;
        case ARRAY:
            enqueue(schema.getElementType());
            break;
        case UNION:
            for (Schema s : schema.getTypes())
                enqueue(s);
            break;
        case ENUM:
        case FIXED:
            queue.add(schema);
            break;
        case STRING:
        case BYTES:
        case INT:
        case LONG:
        case FLOAT:
        case DOUBLE:
        case BOOLEAN:
        case NULL:
            break;
        default:
            throw new RuntimeException("Unknown type: " + schema);
        }
    }

    /**
     * Generate java classes for enqueued schemas.
     */
    Collection<OutputFile> compile() {
        List<OutputFile> out = new ArrayList<>();
        for (Schema schema : queue) {
            out.add(compile(schema));
        }
        if (protocol != null) {
            Logger logger = LoggerFactory.getLogger(Avro4kCompiler.class);
            logger.warn("Protocol is currently not supported by avro4k. Therefore no generation happens.");
        }
        return out;
    }

    /**
     * Generate output under dst, unless existing file is newer than src.
     */
    public void compileToDestination(File src, File dst) throws IOException {
        for (Schema schema : queue) {
            OutputFile o = compile(schema);
            o.writeToDestination(src, dst);
        }
        if (protocol != null) {
            Logger logger = LoggerFactory.getLogger(Avro4kCompiler.class);
            logger.warn("Protocol is currently not supported by avro4k. Therefore no generation happens.");
        }
    }

    private String renderTemplate(String templateName, VelocityContext context) {
        Template template;
        try {
            template = this.velocityEngine.getTemplate(templateName);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        StringWriter writer = new StringWriter();
        template.merge(context, writer);
        return writer.toString();
    }

    // package private for testing purposes
    String makePath(String name, String space) {
        if (space == null || space.isEmpty()) {
            return name + suffix;
        } else {
            return space.replace('.', File.separatorChar) + File.separatorChar + name + suffix;
        }
    }

    public String escapeJavaString(String str) {
        return StringEscapeUtils.escapeJava(str);
    }

    public String getTemplate(String file) {
        return templateDir + file;
    }

    OutputFile compile(Schema schema) {
        String output = "";
        VelocityContext context = new VelocityContext();
        context.put("this", this);
        context.put("schema", schema);
        for (Object velocityTool : additionalVelocityTools) {
            String toolName = velocityTool.getClass().getSimpleName().toLowerCase();
            context.put(toolName, velocityTool);
        }

        switch (schema.getType()) {
        case RECORD:
            output = renderTemplate(getTemplate("record.vm"), context);
            break;
        case ENUM:
            output = renderTemplate(getTemplate("enum.vm"), context);
            break;
        case FIXED:
            output = renderTemplate(getTemplate("fixed.vm"), context);
            break;
        case BOOLEAN:
        case NULL:
            break;
        default:
            throw new RuntimeException("Unknown type: " + schema);
        }

        OutputFile outputFile = new OutputFile();
        String name = mangle(name(schema));
        outputFile.path = makePath(name, namespace(schema));
        outputFile.contents = output;
        outputFile.outputCharacterEncoding = outputCharacterEncoding;
        return outputFile;
    }

    /**
     * Utility for template use. Returns the kotlin type for a Schema.
     */
    public String kotlinType(Schema schema) {
        return kotlinType(schema, true);
    }

    public Optional<String> serializerAnnotation(Schema schema) {
        return getLogicalTypeConversion(schema).map(logicalType -> {
            Schema lookupSchema = isNullableUnion(schema) ? extractNonNullableType(schema) : schema;
            return logicalType.getSerializationAnnotation(lookupSchema);
        });
    }

    private boolean isNullableUnion(Schema schema) {
        if (schema.getType() == Schema.Type.UNION) {
            List<Schema> types = schema.getTypes();
            return types.size() == 2 && types.contains(NULL_SCHEMA);
        } else {
            return false;
        }
    }

    private Schema extractNonNullableType(Schema schema) {
        List<Schema> types = schema.getTypes();
        return types.get(types.get(0).equals(NULL_SCHEMA) ? 1 : 0);
    }

    private String kotlinType(Schema schema, boolean checkConvertedLogicalType) {
        if (checkConvertedLogicalType) {
            Optional<String> convertedLogicalType = getConvertedLogicalType(schema);
            if (convertedLogicalType.isPresent()) {
                return convertedLogicalType.get();
            }
        }

        switch (schema.getType()) {
        case RECORD:
        case ENUM:
        case FIXED:
            return mangle(fullName(schema));
        case ARRAY:
            return "kotlin.collections.List<" + kotlinType(schema.getElementType()) + ">";
        case MAP:
            return "kotlin.collections.Map<String," + kotlinType(schema.getValueType()) + ">";
        case UNION:
            List<Schema> types = schema.getTypes(); // elide unions with null
            if (isNullableUnion(schema))
                return kotlinType(extractNonNullableType(schema)) + "?";
            return "Any";
        case STRING:
            return "String";
        case BYTES:
            return "ByteArray";
        case INT:
            return "Int";
        case LONG:
            return "Long";
        case FLOAT:
            return "Float";
        case DOUBLE:
            return "Double";
        case BOOLEAN:
            return "Boolean";
        case NULL:
            return "Nothing";
        default:
            throw new RuntimeException("Unknown type: " + schema);
        }
    }

    private Optional<LogicalTypeConversion> getLogicalTypeConversion(Schema schema) {
        Schema lookupSchema = isNullableUnion(schema) ? extractNonNullableType(schema) : schema;
        return lookupSchema.getLogicalType() == null ?
                Optional.empty() :
                this.logicalTypeConversions.stream()
                        .filter(type -> type.getLogicalTypeName().equals(lookupSchema.getLogicalType().getName()))
                        .findFirst();
    }

    private Optional<String> getConvertedLogicalType(Schema schema) {
        return getLogicalTypeConversion(schema).map(LogicalTypeConversion::getKotlinType);
    }

    private String getMappedName(Schema schema) {
        String fullName = schema.getFullName();
        for (Map.Entry<String, String> nameMappings : this.renamedClasses.entrySet()) {
            String newFullname = fullName.replaceAll(nameMappings.getKey(), nameMappings.getValue());
            if (!newFullname.equals(fullName)) {
                return newFullname;
            }
        }
        return null;
    }

    public String namespace(Schema schema) {
        String newFullName = getMappedName(schema);
        if (newFullName == null) {
            return schema.getNamespace();
        }
        return newFullName.indexOf('.') != -1 ? newFullName.substring(0, newFullName.lastIndexOf('.')) : "";
    }

    public String name(Schema schema) {
        String newFullName = getMappedName(schema);
        if (newFullName == null) {
            return schema.getName();
        }
        return newFullName.indexOf('.') != -1 ? newFullName.substring(newFullName.lastIndexOf('.') + 1) : newFullName;
    }

    public String fullName(Schema schema) {
        String mappedName = getMappedName(schema);
        return mappedName != null ? mappedName : schema.getFullName();
    }

    public boolean annotateSerializable(Schema schema) {
        boolean doAnnotate = false;
        switch (schema.getType()) {
        case ENUM:
            doAnnotate = schema.getDoc() != null || !schema.getAliases().isEmpty();
            break;
        default:
            doAnnotate = true;
            break;
        }
        return doAnnotate;
    }

    public boolean isNameMapped(Schema schema) {
        return getMappedName(schema) != null;
    }

    public boolean isDefaultValueNull(Field field) {
        return field.defaultVal() == JsonProperties.NULL_VALUE;
    }

    public String defaultValue(Field field) {
        Object defaultvalue = field.defaultVal();
        if (JsonProperties.NULL_VALUE == defaultvalue) {
            return null;
        } else {
            return defaultvalue.toString();
        }
    }

    public String defaultValueAsKotlinValue(Field field) {
        if (!field.hasDefaultValue()) {
            return "";
        }
        Object defaultValue = field.defaultVal();
        if (defaultValue == JsonProperties.NULL_VALUE) {
            return "null";
        }
        if (field.schema().getType() == Schema.Type.ENUM) {
            return fullName(field.schema()) + "." + defaultValue;
        }
        Optional<LogicalTypeConversion> logicalType = getLogicalTypeConversion(field.schema());
        if (logicalType.isPresent()) {
            return logicalType.get().getKotlinDefaultString(field.schema(), defaultValue);
        } else if (defaultValue instanceof String) {
            return "\"" + escapeJavaString((String) defaultValue) + "\"";
        } else if (defaultValue instanceof Long) {
            return defaultValue + "L";
        } else if (defaultValue instanceof BigDecimal) {
            return "java.math:BigDecimal(\"" + defaultValue.toString() + "\")";
        } else if (defaultValue instanceof Float) {
            return defaultValue + "f";
        } else if (defaultValue instanceof Number) {
            return defaultValue.toString();
        } else {
            return defaultValue.toString();
        }
    }

    public String kotlinUnbox(Schema schema) {
        Optional<String> convertedLogicalType = getConvertedLogicalType(schema);
        if (convertedLogicalType.isPresent()) {
            String nonNullableType = convertedLogicalType.get();
            if (isNullableUnion(schema)) {
                return nonNullableType + "?";
            } else {
                return nonNullableType;
            }
        }

        switch (schema.getType()) {
        case INT:
            return "Int";
        case LONG:
            return "Long";
        case FLOAT:
            return "Float";
        case DOUBLE:
            return "Double";
        case BOOLEAN:
            return "Boolean";
        default:
            return kotlinType(schema, false);
        }
    }

    private boolean isCustomCodable(Schema schema, Set<Schema> seen) {
        if (!seen.add(schema))
            return true;
        if (schema.getLogicalType() != null)
            return false;
        boolean result = true;
        switch (schema.getType()) {
        case RECORD:
            for (Schema.Field f : schema.getFields())
                result &= isCustomCodable(f.schema(), seen);
            break;
        case MAP:
            result = isCustomCodable(schema.getValueType(), seen);
            break;
        case ARRAY:
            result = isCustomCodable(schema.getElementType(), seen);
            break;
        case UNION:
            List<Schema> types = schema.getTypes();
            // Only know how to handle "nulling" unions for now
            if (types.size() != 2 || !types.contains(NULL_SCHEMA))
                return false;
            for (Schema s : types)
                result &= isCustomCodable(s, seen);
            break;
        default:
        }
        return result;
    }

    /**
     * Utility for template use. Returns the java annotations for a schema.
     */
    public String[] javaAnnotations(JsonProperties props) {
        Object value = props.getObjectProp("javaAnnotation");
        if (value == null)
            return new String[0];
        if (value instanceof String)
            return new String[] { value.toString() };
        if (value instanceof List) {
            List<?> list = (List<?>) value;
            List<String> annots = new ArrayList<>();
            for (Object o : list)
                annots.add(o.toString());
            return annots.toArray(new String[0]);
        }
        return new String[0];
    }

    /**
     * Sets character encoding for generated java file
     *
     * @param outputCharacterEncoding Character encoding for output files (defaults
     *                                to system encoding)
     */
    public void setOutputCharacterEncoding(String outputCharacterEncoding) {
        this.outputCharacterEncoding = outputCharacterEncoding;
    }

    public enum FieldVisibility {
        PRIVATE, PROTECTED, PUBLIC, INTERNAL
    }

    /**
     * Captures output file path and contents.
     */
    static class OutputFile {
        String path;
        String contents;
        String outputCharacterEncoding;

        /**
         * Writes output to path destination directory when it is newer than src,
         * creating directories as necessary. Returns the created file.
         */
        File writeToDestination(File src, File destDir) throws IOException {
            File f = new File(destDir, path);
            if (src != null && f.exists() && f.lastModified() >= src.lastModified())
                return f; // already up to date: ignore
            f.getParentFile().mkdirs();
            Writer fw = null;
            FileOutputStream fos = null;
            try {
                if (outputCharacterEncoding != null) {
                    fos = new FileOutputStream(f);
                    fw = new OutputStreamWriter(fos, outputCharacterEncoding);
                } else {
                    fw = Files.newBufferedWriter(f.toPath(), UTF_8);
                }
                fw.write(FILE_HEADER);
                fw.write(contents);
            } finally {
                if (fw != null)
                    fw.close();
                if (fos != null)
                    fos.close();
            }
            return f;
        }
    }
}
